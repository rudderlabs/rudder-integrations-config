"""
    Usage: schemaGenerator.py [-h] [-name name | -all] [-update] selector
        1. selector - “source” or “destination”
        2. all - runs the validator for all the selector.
        3. name - any particular source or destination name such as `google_analytics`
        3. update - updates existing schema with detected changes
    Example:
        1. python3 scripts/schemaGenerator.py -name="adobe_analytics" destination
        2. python3 scripts/schemaGenerator.py -all source
"""

import os
import warnings
from enum import Enum
import argparse
import json
from utils import get_json_from_file, get_json_diff, apply_json_diff, get_formatted_json
from constants import CONFIG_DIR

EXCLUDED_DEST = ["postgres", "bq", "azure_synapse", "clickhouse", "deltalake", "kafka"]


class FieldTypeEnum(Enum):
    STRING = "string"
    OBJECT = "object"
    BOOLEAN = "boolean"
    ARRAY = "array"


def is_old_format(uiConfig):
    if isinstance(uiConfig, dict):
        return False
    return True


def get_options_list_for_enum(field):
    """Creates the list of options given in field and return the list
    Args:
        field (object): Individual field in ui-config.
    Returns:
        list: list of options
    """
    options_list = []
    for i in range(0, len(field["options"])):
        if isinstance(field["options"][i], int) or isinstance(field["options"][i], str):
            options_list.append(field["options"][i])
        else:
            options_list.append(field["options"][i]["value"])
    # allow empty field in enum if field in not required.
    if (
        "default" not in field
        and "defaultOption" not in field
        and field.get("required", False) == False
    ):
        options_list.append("")
    return options_list


def generalize_regex_pattern(field):
    """Generates the pattern for schema based on the type of field.
    - For type : singleSelect and dynamicSelectForm, the pattern is generated by iterating over options.
    - For other types,
        - If the field contains regex, then regex is the pattern; it gets prefixed with a default prefix if regex does not have it.
        - Else, the default prefix is appended with ^(.{0,100}).

    Args:
        field (object): Individual field in ui-config, includes properties such as label, type, name, regex etc.

    Returns:
        string: generated pattern for the field.
    """
    defaultSubPattern = "(^\\{\\{.*\\|\\|(.*)\\}\\}$)"
    defaultEnvPattern = "(^env[.].+)"
    pattern = ""
    if "regex" in field:
        pattern = field["regex"]
        if defaultSubPattern not in pattern and (
            ("value" not in field or field["value"] != "purpose")
            and ("configKey" not in field or field["configKey"] != "purpose")
        ):
            pattern = "|".join([defaultSubPattern, pattern])
        if defaultEnvPattern not in pattern and (
            ("value" not in field or field["value"] != "purpose")
            and ("configKey" not in field or field["configKey"] != "purpose")
        ):
            indexToPlace = pattern.find(defaultSubPattern) + len(defaultSubPattern)
            pattern = (
                pattern[:indexToPlace]
                + "|"
                + defaultEnvPattern
                + pattern[indexToPlace:]
            )
    # TODO: we should not use a case here for the individual properties. Just pass the desired pattern as regex property
    #  in ketch purpose fields and delete next case
    elif ("value" in field and field["value"] == "purpose") or (
        "configKey" in field and field["configKey"] == "purpose"
    ):
        pattern = "^(.{0,100})$"
    else:
        pattern = "|".join([defaultSubPattern, defaultEnvPattern, "^(.{0,100})$"])
    return pattern


def is_dest_field_dependent_on_source(field, dbConfig, schema_field_name):
    """Checks if the given field is source-specific by using dbConfig.
    In dbConfig all the sources are listed in 'supportedSourceTypes',
    and their fields are listed inside 'destConfig' with the key as the source.

    Args:
        field (object): Individual field in ui-config.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.


    Returns:
        boolean: True if the field is source dependent else, False.
    """
    if not dbConfig:
        return False
    for sourceType in dbConfig["supportedSourceTypes"]:
        if (
            sourceType in dbConfig["destConfig"]
            and field[schema_field_name] in dbConfig["destConfig"][sourceType]
        ):
            return True
    return False


def is_field_present_in_default_config(field, dbConfig, schema_field_name):
    """Checks if the given field is present in defaultConfig list present in dbConfig.

    Args:
        field (object): Individual field in ui-config.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        boolean: True if field is in defaultConfig else False.
    """
    if not dbConfig:
        return False
    if (
        "destConfig" in dbConfig
        and "defaultConfig" in dbConfig["destConfig"]
        and field[schema_field_name] in dbConfig["destConfig"]["defaultConfig"]
    ):
        return True
    return False


def generate_schema_for_default_checkbox(field, dbConfig, schema_field_name):
    """Creates a schema object of defaultCheckbox.

    Args:
        field (object): Individual field in ui-config.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        object
    """
    isSourceDependent = is_dest_field_dependent_on_source(
        field, dbConfig, schema_field_name
    )
    defaultCheckboxSchemaObj = {}
    if isSourceDependent:
        defaultCheckboxSchemaObj["type"] = FieldTypeEnum.OBJECT.value
        defaultCheckboxSchemaObj["properties"] = {}
        # iterates over supported sources and sets the field for that source if field is present inside that source
        for sourceType in dbConfig["supportedSourceTypes"]:
            if (
                sourceType in dbConfig["destConfig"]
                and field[schema_field_name] in dbConfig["destConfig"][sourceType]
            ):
                defaultCheckboxSchemaObj["properties"][sourceType] = {
                    "type": FieldTypeEnum.BOOLEAN.value
                }
    else:
        defaultCheckboxSchemaObj["type"] = FieldTypeEnum.BOOLEAN.value
        if "default" in field:
            defaultCheckboxSchemaObj["default"] = field["default"]
    return defaultCheckboxSchemaObj


def generate_schema_for_checkbox(field, dbConfig, schema_field_name):
    """Creates a schema object of checkbox.

    Args:
        field (object): Individual field in ui-config.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        object
    """
    isSourceDependent = is_dest_field_dependent_on_source(
        field, dbConfig, schema_field_name
    )
    checkboxSchemaObj = {}
    if isSourceDependent:
        checkboxSchemaObj["type"] = FieldTypeEnum.OBJECT.value
        checkboxSchemaObj["properties"] = {}
        # iterates over supported sources and sets the field for that source if field is present inside that source
        for sourceType in dbConfig["supportedSourceTypes"]:
            if (
                sourceType in dbConfig["destConfig"]
                and field[schema_field_name] in dbConfig["destConfig"][sourceType]
            ):
                checkboxSchemaObj["properties"][sourceType] = {
                    "type": FieldTypeEnum.BOOLEAN.value
                }
    else:
        checkboxSchemaObj["type"] = FieldTypeEnum.BOOLEAN.value
        if "default" in field:
            checkboxSchemaObj["default"] = field["default"]
    return checkboxSchemaObj


def generate_schema_for_textinput(field, dbConfig, schema_field_name):
    """Creates a schema object of textinput.

    Args:
        field (object): Individual field in ui-config.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        object
    """
    textInputSchemaObj = {}
    isSourceDependent = is_dest_field_dependent_on_source(
        field, dbConfig, schema_field_name
    )
    if isSourceDependent:
        textInputSchemaObj["type"] = FieldTypeEnum.OBJECT.value
        textInputSchemaObj["properties"] = {}
        # iterates over supported sources and sets the field for that source if field is present inside that source
        for sourceType in dbConfig["supportedSourceTypes"]:
            if (
                sourceType in dbConfig["destConfig"]
                and field[schema_field_name] in dbConfig["destConfig"][sourceType]
            ):
                textInputSchemaObj["properties"][sourceType] = {
                    "type": FieldTypeEnum.STRING.value
                }
                if "regex" in field:
                    textInputSchemaObj["properties"][sourceType]["pattern"] = (
                        generalize_regex_pattern(field)
                    )
    else:
        textInputSchemaObj = {"type": FieldTypeEnum.STRING.value}
        if "regex" in field:
            textInputSchemaObj["pattern"] = generalize_regex_pattern(field)
    return textInputSchemaObj


def generate_schema_for_textarea_input(field, dbConfig, schema_field_name):
    """Creates a schema object of textareaInput.

    Args:
        field (object): Individual field in ui-config.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        object
    """
    textareaInputObj = {"type": FieldTypeEnum.STRING.value}
    if "regex" in field:
        textareaInputObj["pattern"] = generalize_regex_pattern(field)
    return textareaInputObj


def generate_schema_for_single_select(field, dbConfig, schema_field_name):
    """Creates a schema object of singleSelect.

    Args:
        field (object): Individual field in ui-config.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        object
    """
    singleSelectObj = {}
    if "mode" in field and field["mode"] == "multiple":
        singleSelectObj = {"type": FieldTypeEnum.ARRAY.value}
        singleSelectObj["items"] = {
            "type": FieldTypeEnum.STRING.value,
            "enum": get_options_list_for_enum(field),
        }
        if "default" or "defaultOption" in field:
            if isinstance(field["defaultOption"]["value"], list):
                singleSelectObj["default"] = field["defaultOption"]["value"]
            elif field["defaultOption"]["value"]:
                singleSelectObj["default"] = [field["defaultOption"]["value"]]
            elif "default" in field:
                singleSelectObj["default"] = field["default"]
    else:
        singleSelectObj = {"type": FieldTypeEnum.STRING.value}
        singleSelectObj["enum"] = get_options_list_for_enum(field)
        if "default" or "defaultOption" in field:
            if "defaultOption" in field:
                singleSelectObj["default"] = field["defaultOption"]["value"]
            elif "default" in field:
                singleSelectObj["default"] = field["default"]

    isSourceDependent = is_dest_field_dependent_on_source(
        field, dbConfig, schema_field_name
    )
    if isSourceDependent:
        newSingleSelectObj = {"type": FieldTypeEnum.OBJECT.value}
        newSingleSelectObj["properties"] = {}
        # iterates over supported sources and sets the field for that source if field is present inside that source
        for sourceType in dbConfig["supportedSourceTypes"]:
            if (
                sourceType in dbConfig["destConfig"]
                and field[schema_field_name] in dbConfig["destConfig"][sourceType]
            ):
                newSingleSelectObj["properties"][sourceType] = singleSelectObj
        singleSelectObj = newSingleSelectObj
    return singleSelectObj


def generate_schema_for_dynamic_custom_form(field, dbConfig, schema_field_name):
    """Creates a schema object of dynamicCustomForm.

    Args:
        field (object): Individual field in ui-config.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        object
    """
    dynamicCustomFormObj = {}
    dynamicCustomFormObj["type"] = FieldTypeEnum.ARRAY.value
    dynamicCustomFormItemObj = {}
    dynamicCustomFormItemObj["type"] = FieldTypeEnum.OBJECT.value
    dynamicCustomFormItemObj["properties"] = {}
    allOfSchemaObj = {}

    # For old schema types customFields contains the children, for v2 its is rowFields
    customFieldsKey = "customFields"
    if "rowFields" in field:
        customFieldsKey = "rowFields"

    allOfSchemaObj = generate_schema_for_dynamic_custom_form_allOf(
        field[customFieldsKey], dbConfig, schema_field_name
    )

    for customField in field[customFieldsKey]:
        customFieldSchemaObj = uiTypetoSchemaFn.get(customField["type"])(
            customField, dbConfig, schema_field_name
        )
        isCustomFieldDependentOnSource = is_dest_field_dependent_on_source(
            customField, dbConfig, schema_field_name
        )

        if "preRequisites" in customField:
            continue

        if (
            "pattern" not in customFieldSchemaObj
            and not isCustomFieldDependentOnSource
            and customFieldSchemaObj["type"] == FieldTypeEnum.STRING.value
            and customField["type"] != "singleSelect"
            and customField["type"] != "dynamicSelectForm"
        ):
            customFieldSchemaObj["pattern"] = generalize_regex_pattern(customField)

        # If the custom field is source dependent, we remove the source keys as it's not required inside custom fields, rather they need to be moved to top.
        if isCustomFieldDependentOnSource:
            for sourceType in dbConfig["supportedSourceTypes"]:
                if (
                    sourceType in dbConfig["destConfig"]
                    and field[schema_field_name] in dbConfig["destConfig"][sourceType]
                ):
                    customFieldSchemaObj = customFieldSchemaObj["properties"][
                        sourceType
                    ]
                    break
        dynamicCustomFormItemObj["properties"][
            customField[schema_field_name]
        ] = customFieldSchemaObj

    if allOfSchemaObj:
        dynamicCustomFormItemObj["allOf"] = allOfSchemaObj

    dynamicCustomFormObj["items"] = dynamicCustomFormItemObj
    isSourceDependent = is_dest_field_dependent_on_source(
        field, dbConfig, schema_field_name
    )

    # If the field is source dependent, new schema object is created by setting the fields inside the source.
    if isSourceDependent:
        newDynamicCustomFormObj = {"type": FieldTypeEnum.OBJECT.value}
        newDynamicCustomFormObj["properties"] = {}
        for sourceType in dbConfig["supportedSourceTypes"]:
            if (
                sourceType in dbConfig["destConfig"]
                and field[schema_field_name] in dbConfig["destConfig"][sourceType]
            ):
                newDynamicCustomFormObj["properties"][sourceType] = dynamicCustomFormObj
        dynamicCustomFormObj = newDynamicCustomFormObj

    return dynamicCustomFormObj


def generate_schema_for_dynamic_custom_form_allOf(
    customFields, dbConfig, schema_field_name
):
    """Creates the allOf structure of schema, empty if not required.
    - Finds the list of unique preRequisites.
    - For each unique preRequisites, the properties are found by matching the current preRequisites.
    - preRequisites becomes if block and corresponding properties become then block.

    Args:
        customFields (collection): child fields from file content of ui-config.json.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        object: allOf object of schema
    """
    allOfItemList = []
    preRequisitesList = []

    for field in customFields:
        if "preRequisites" not in field:
            continue
        isPresent = False
        for preRequisites in preRequisitesList:
            if compare_pre_requisite_fields(
                preRequisites, field["preRequisites"]["fields"], True
            ):
                isPresent = True
                break
        if not isPresent:
            preRequisitesList.append(field["preRequisites"]["fields"])

    for preRequisites in preRequisitesList:
        ifObj = generate_if_object(preRequisites, True)
        thenObj = {"properties": {}, "required": []}
        allOfItemObj = {"if": ifObj}

        for field in customFields:
            if "preRequisites" not in field:
                continue
            if compare_pre_requisite_fields(
                field["preRequisites"]["fields"], preRequisites, True
            ):
                thenObj["properties"][field[schema_field_name]] = uiTypetoSchemaFn.get(
                    field["type"]
                )(field, dbConfig, schema_field_name)
                if "required" in field and field["required"] == True:
                    thenObj["required"].append(field[schema_field_name])
        allOfItemObj["then"] = thenObj
        allOfItemList.append(allOfItemObj)

    # Calling anyOf to check if two conditions can be grouped as anyOf.
    allOfItemList = generate_schema_for_anyOf(allOfItemList, schema_field_name)
    return allOfItemList


def generate_schema_for_dynamic_form(field, dbConfig, schema_field_name):
    """Creates a schema object of dynamicForm.

    Args:
        field (object): Individual field in ui-config.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        object
    """

    def generate_key(forFieldWithTo):
        obj = {
            "type": FieldTypeEnum.STRING.value,
        }
        if field["type"] == "dynamicSelectForm":
            if forFieldWithTo != (field.get("reverse", False) == False):
                obj["pattern"] = generalize_regex_pattern(field)
            else:
                if "defaultOption" in field:
                    obj["default"] = field["defaultOption"]["value"]
                obj["enum"] = get_options_list_for_enum(field)
        else:
            obj["pattern"] = generalize_regex_pattern(field)
        return obj

    dynamicFormSchemaObject = {}
    dynamicFormSchemaObject["type"] = FieldTypeEnum.ARRAY.value
    dynamicFormItemObject = {}
    dynamicFormItemObject["type"] = FieldTypeEnum.OBJECT.value
    dynamicFormItemObject["properties"] = {}
    dynamicFormItemObjectProps = [
        (field["keyLeft"], generate_key),
        (field["keyRight"], generate_key),
    ]
    for dynamicFromItemObjectProp in dynamicFormItemObjectProps:
        dynamicFormItemObject["properties"][dynamicFromItemObjectProp[0]] = (
            dynamicFromItemObjectProp[1](dynamicFromItemObjectProp[0] == "to")
        )
    dynamicFormSchemaObject["items"] = dynamicFormItemObject

    isSourceDependent = is_dest_field_dependent_on_source(
        field, dbConfig, schema_field_name
    )
    # If the field is source dependent, new schema object is created by setting the fields inside the source.
    if isSourceDependent:
        newDynamicFormFormObj = {"type": FieldTypeEnum.OBJECT.value}
        newDynamicFormFormObj["properties"] = {}
        for sourceType in dbConfig["supportedSourceTypes"]:
            if (
                sourceType in dbConfig["destConfig"]
                and field[schema_field_name] in dbConfig["destConfig"][sourceType]
            ):
                newDynamicFormFormObj["properties"][
                    sourceType
                ] = dynamicFormSchemaObject
        dynamicFormSchemaObject = newDynamicFormFormObj
    return dynamicFormSchemaObject


def generate_schema_for_dynamic_select_form(field, dbConfig, schema_field_name):
    """Creates a schema object of dynamicSelectForm.

    Args:
        field (object): Individual field in ui-config.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        object
    """
    return generate_schema_for_dynamic_form(field, dbConfig, schema_field_name)


def generate_schema_for_mapping(field, dbConfig, schema_field_name):
    """Creates a schema object of mapping.

    Args:
        field (object): Individual field in ui-config.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        object
    """
    return generate_schema_for_dynamic_form(field, dbConfig, schema_field_name)


def generate_schema_for_tag_input(field, dbConfig, schema_field_name):
    """Creates a schema object of tagInput.

    Args:
        field (object): Individual field in ui-config.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        object
    """
    tagObject = {}
    tagObject["type"] = FieldTypeEnum.ARRAY.value
    tagItem = {}
    tagItem["type"] = FieldTypeEnum.OBJECT.value
    tagItemProps = {
        str(field["tagKey"]): {
            "type": FieldTypeEnum.STRING.value,
            "pattern": generalize_regex_pattern(field),
        }
    }
    tagItem["properties"] = tagItemProps
    tagObject["items"] = tagItem
    isSourceDependent = is_dest_field_dependent_on_source(
        field, dbConfig, schema_field_name
    )
    if isSourceDependent:
        tagObjectCopy = tagObject
        tagObject = {}
        tagObject = {"type": FieldTypeEnum.OBJECT.value}
        tagObject["properties"] = {}
        for sourceType in dbConfig["supportedSourceTypes"]:
            if (
                sourceType in dbConfig["destConfig"]
                and field[schema_field_name] in dbConfig["destConfig"][sourceType]
            ):
                tagObject["properties"][sourceType] = tagObjectCopy
    return tagObject


def generate_schema_for_time_range_picker(field, dbConfig, schema_field_name):
    """Creates a schema object of timeRangePicker.

    Args:
        field (object): Individual field in ui-config.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        object
    """
    timeRangeObj = {}
    timeRangeObj["type"] = FieldTypeEnum.OBJECT.value
    timeRangeProps = {
        field["startTime"]["value"]: {"type": FieldTypeEnum.STRING.value},
        field["endTime"]["value"]: {"type": FieldTypeEnum.STRING.value},
    }
    timeRangeObj["properties"] = timeRangeProps
    timeRangeObj["required"] = list(timeRangeProps.keys())
    return timeRangeObj


def generate_schema_for_time_picker(field, dbConfig, schema_field_name):
    """Creates a schema object of timePicker.

    Args:
        field (object): Individual field in ui-config.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        object
    """
    return {"type": FieldTypeEnum.STRING.value}


def compare_pre_requisite_fields(fieldA, fieldB, isV2=False):
    """Compares two preRequisiteFields fieldA and fieldB for each property and checks if their value matches.

    Args:
        fieldA (list or object): contains two properties representing 'name' and 'selectedValue'.
        fieldB (list or object): contains two properties representing 'name' and 'selectedValue'.
        isV2 (bool): determines if new property names should be used

    Returns:
        boolean: If all the properties have the same 'name' and 'selectedValue', then it returns True else False.
    """
    valueKey = "selectedValue"
    nameKey = "name"

    if isV2:
        valueKey = "value"
        nameKey = "configKey"

    if type(fieldA) != type(fieldB):
        return False
    elif type(fieldA) == list:
        if len(fieldA) != len(fieldB):
            return False
        for i in range(0, len(fieldA)):
            if (
                fieldA[i][nameKey] != fieldB[i][nameKey]
                or fieldA[i][valueKey] != fieldB[i][valueKey]
            ):
                return False
    else:
        if fieldA[nameKey] != fieldB[nameKey] or fieldA[valueKey] != fieldB[valueKey]:
            return False
    return True


def get_unique_pre_requisite_fields(uiConfig):
    """Returns the list of unique preRequisiteFields present in a uiConfig.

    Args:
        uiConfig (object): file content of ui-config.json.

    Returns:
        list: containing unique preRequisiteFields.
    """
    preRequisiteFieldsList = []
    for group in uiConfig:
        fields = group.get("fields", [])
        for field in fields:
            if "preRequisiteField" not in field:
                continue
            isPresent = False
            for preRequisiteField in preRequisiteFieldsList:
                if compare_pre_requisite_fields(
                    preRequisiteField, field["preRequisiteField"]
                ):
                    isPresent = True
                    break
            if not isPresent:
                preRequisiteFieldsList.append(field["preRequisiteField"])
    return preRequisiteFieldsList


def generate_if_object(preRequisiteField, isV2=False):
    """Creates an if object for the given preRequisiteField. The preRequisiteField becomes an if condition in the schema.

    Args:
        preRequisiteField (list or object): contains two properties, 'name' and 'selectedValue'.
        isV2 (bool): if it should use the v2 or the legacy property key names

    Returns:
        object: if block for given preRequisiteField.
    """
    ifObj = {"properties": {}, "required": []}
    valueKey = "selectedValue"
    nameKey = "name"

    if isV2:
        valueKey = "value"
        nameKey = "configKey"

    if type(preRequisiteField) == list:
        for field in preRequisiteField:
            ifObj["properties"][field[nameKey]] = {"const": field[valueKey]}
            ifObj["required"].append(field[nameKey])
    else:
        ifObj["properties"][preRequisiteField[nameKey]] = {
            "const": preRequisiteField[valueKey]
        }
        ifObj["required"].append(preRequisiteField[nameKey])
    return ifObj


def generate_schema_for_allOf(uiConfig, dbConfig, schema_field_name):
    """Creates the allOf structure of schema, empty if not required.
    - Finds the list of unique preRequisiteFields.
    - For each unique preRequisiteField, the properties are found by matching the current preRequisiteField.
    - preRequisiteField becomes if block and corresponding properties become then block.

    Args:
        uiConfig (object): file content of ui-config.json.
        dbConfig (object): Configurations of db-config.json.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        object: allOf object of schema
    """
    allOfItemList = []
    preRequisiteFieldsList = get_unique_pre_requisite_fields(uiConfig)
    for preRequisiteField in preRequisiteFieldsList:
        ifObj = generate_if_object(preRequisiteField)
        thenObj = {"properties": {}, "required": []}
        allOfItemObj = {"if": ifObj}
        for group in uiConfig:
            fields = group.get("fields", [])
            for field in fields:
                if "preRequisiteField" not in field:
                    continue
                if compare_pre_requisite_fields(
                    field["preRequisiteField"], preRequisiteField
                ):
                    thenObj["properties"][field[schema_field_name]] = (
                        uiTypetoSchemaFn.get(field["type"])(
                            field, dbConfig, schema_field_name
                        )
                    )
                    if "required" in field and field["required"] == True:
                        thenObj["required"].append(field[schema_field_name])
        allOfItemObj["then"] = thenObj
        allOfItemList.append(allOfItemObj)
    # Calling anyOf to check if two conditions can be grouped as anyOf.
    allOfItemList = generate_schema_for_anyOf(allOfItemList, schema_field_name)
    return allOfItemList


def get_common_and_opposite_fields(propertiesA, propertiesB, schema_field_name):
    """Takes properties of two if Objects and returns a list of common and opposite properties.
    Common properties have the same value in both A and B.

    Args:
        propertiesA (object): if block
        propertiesB (object):
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        list, list : list of common properties and opposite properties respectively.
        None, None : if a property is absent in A or B or If a property has a different value (not opposite).

    Example:
        schema_field_name = 'value'
        propertiesA = { 'storage' : {'const' : 'S3'}, 'useStorage' : {'const': True}}
        propertiesB = { 'storage' : {'const' : 'S3'}, 'useStorage' : {'const': False}}

        Returns
        commonProperties = [{'key': 'storage', 'value':'S3'}]
        oppositeProperties = [{'key': 'useStorage', 'value': 'True'}]
    """
    keysListA = list(propertiesA.keys())
    keysListB = list(propertiesB.keys())
    commonProperties = []
    oppositeProperties = []
    for key in keysListA:
        if key not in keysListB:
            return None, None
        if propertiesA[key]["const"] == propertiesB[key]["const"]:
            commonProperties.append(
                {"key": key, schema_field_name: propertiesA[key]["const"]}
            )
        elif (
            type(propertiesA[key]["const"]) == bool
            and propertiesA[key]["const"] != propertiesB[key]["const"]
        ):
            oppositeProperties.append(
                {"key": key, schema_field_name: propertiesA[key]["const"]}
            )
        else:
            return None, None
    return commonProperties, oppositeProperties


def check_if_conditions_match(ifPropsA, ifObjectB, schema_field_name):
    """Compares the ifPropsA and ifObjectB if they have the same properties and values.

    Args:
        ifPropsA (list): consists of key and "schema_field_name" pairs.
        ifObjectB (object): if block consisting of multiple properties with the value.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        boolean: True if all the properties in IfPropsA are in ifObjectB with same value, else False.

    Example:
        schema_field_name = 'value'
        ifPropsA = [{'key': 'storage', 'value': 'S3'}, {'key': 'deploy', 'value': 'web'}]
        ifObjectA  = {'storage': {'const': 'S3'}, 'deploy': {'const': 'web'}}

        Returns: True
    """
    for ifProp in ifPropsA:
        if ifProp["key"] not in ifObjectB:
            return False
        if ifProp[schema_field_name] != ifObjectB[ifProp["key"]]["const"]:
            return False
    return True


def find_index_to_place_anyOf(ifProp, allOfItemList, schema_field_name):
    """Returns the index of the item in allOfItemList consisting of matching if conditions as that of ifProp.

    Args:
        ifProp (object): consists of key and "schema_field_name" pairs.
        allOfItemList (list): consists of a list of objects with "if-then" properties.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        int: index of if-block matching with ifProp else -1.

    Example:
        schema_field_name = 'value'
        ifProp = [{'key': 'storage', 'value': 'S3'}, {'key': 'deploy', 'value': 'web'}]
        allOfItemList = [
            {'if': {'properties': {'storage': { const: 'GCS' }}},'then': { ... }},
            {'if': {'properties': {'storage': { const: 'S3' },'deploy': { const: 'web' }}},'then': { ... }}
        ]

        Returns: 1
    """
    if not ifProp:
        return -1
    length = len(allOfItemList)
    for index in range(length):
        if "if" in allOfItemList[index] and check_if_conditions_match(
            ifProp, allOfItemList[index]["if"]["properties"], schema_field_name
        ):
            return index
    return -1


def generate_schema_for_anyOf(allOfItemList, schema_field_name):
    """Takes in two parameters allOfItemList and schema_field_name, and returns an updated allOf Items list.
    - It checks for all the pairs of allOf Items ("if-then" blocks), if their "if" conditions have an "if-else" based structure rather than "if-if".
    - Items following the "if-else" structure are deleted and replaced by an anyOf structure.

    Args:
        allOfItemList (list): consists of a list of objects with "if-then" properties.
        schema_field_name (string): Specifies which key has the field's name in schema.
            For old schema types, it is 'value' else 'configKey'.

    Returns:
        list: updated allOf Items list
    """
    length = len(allOfItemList)
    delIndices = []
    for i in range(0, length):
        for j in range(i + 1, length):
            ifPropertiesA = allOfItemList[i]["if"]["properties"]
            thenPropertiesA = allOfItemList[i]["then"]
            ifPropertiesB = allOfItemList[j]["if"]["properties"]
            thenPropertiesB = allOfItemList[j]["then"]
            commonIfProp, oppositeIfProp = get_common_and_opposite_fields(
                ifPropertiesA, ifPropertiesB, schema_field_name
            )
            if oppositeIfProp:
                anyOfObj = [{}, {}]
                for k in range(0, len(oppositeIfProp)):
                    if ifPropertiesA[oppositeIfProp[k]["key"]]["const"] == True:
                        anyOfObj[1] = thenPropertiesA
                        anyOfObj[1]["properties"][oppositeIfProp[k]["key"]] = {
                            "const": True
                        }
                        anyOfObj[1]["required"].append(oppositeIfProp[k]["key"])
                        anyOfObj[0] = thenPropertiesB
                        anyOfObj[0]["properties"][oppositeIfProp[k]["key"]] = {
                            "const": False
                        }
                    else:
                        anyOfObj[1] = thenPropertiesB
                        anyOfObj[1]["properties"][oppositeIfProp[k]["key"]] = {
                            "const": True
                        }
                        anyOfObj[1]["required"].append(oppositeIfProp[k]["key"])
                        anyOfObj[0] = thenPropertiesA
                        anyOfObj[0]["properties"][oppositeIfProp[k]["key"]] = {
                            "const": False
                        }
                # AnyOf object is placed at index of "if-then" block having same if properties as of common properties else at end.
                indexToPlace = find_index_to_place_anyOf(
                    commonIfProp, allOfItemList, schema_field_name
                )
                if indexToPlace != -1:
                    allOfItemList[indexToPlace]["then"]["anyOf"] = anyOfObj
                    delIndices.append(i)
                    delIndices.append(j)
    allOfItemList = [
        allOfItemList[index]
        for index in range(len(allOfItemList))
        if index not in delIndices
    ]
    return allOfItemList


def generate_connection_mode(dbConfig):
    """Creates the connection mode object present in new schema types.

    Args:
        dbConfig (object): Configurations of db-config.json.

    Returns:
        object
    """
    connectionObj = {"type": FieldTypeEnum.OBJECT.value}
    connectionObj["properties"] = {}
    for sourceType in dbConfig["supportedSourceTypes"]:
        if sourceType in dbConfig["supportedConnectionModes"]:
            connectionItemObj = {"type": FieldTypeEnum.STRING.value}
            connectionModesEnum = []
            length = len(dbConfig["supportedConnectionModes"][sourceType])
            for i in range(0, length):
                connectionModesEnum.append(
                    dbConfig["supportedConnectionModes"][sourceType][i]
                )
            connectionItemObj["enum"] = connectionModesEnum
            connectionObj["properties"][sourceType] = connectionItemObj
    return connectionObj


def generate_schema_properties(
    uiConfig, dbConfig, schemaObject, properties, name, selector
):
    """Generates corresponding schema properties by iterating over each of the ui-config fields.

    Args:
        uiConfig (object): file content of ui-config.json.
        dbConfig (object): Configurations of db-config.json.
        schemaObject (object): schema being generated
        properties (object): properties of schema
        name (string): name of the source or destination.
        selector (string): either 'source' or 'destination'
    """
    if is_old_format(uiConfig):
        for group in uiConfig:
            fields = group.get("fields", [])
            for field in fields:
                if "preRequisiteField" in field:
                    continue
                generateFunction = uiTypetoSchemaFn.get(field["type"], None)
                if generateFunction:
                    properties[field["value"]] = generateFunction(
                        field, dbConfig, "value"
                    )
                if field.get(
                    "required", False
                ) == True and is_field_present_in_default_config(
                    field, dbConfig, "value"
                ):
                    schemaObject["required"].append(field["value"])
    else:
        if selector == "destination":
            baseTemplate = uiConfig.get("baseTemplate", [])
            sdkTemplate = uiConfig.get("sdkTemplate", {})
            consentSettingsTemplate = uiConfig.get("consentSettingsTemplate", {})
            for template in baseTemplate:
                for section in template.get("sections", []):
                    for group in section.get("groups", []):
                        for field in group.get("fields", []):
                            generateFunction = uiTypetoSchemaFn.get(field["type"], None)
                            if generateFunction:
                                properties[field["configKey"]] = generateFunction(
                                    field, dbConfig, "configKey"
                                )
                            if (
                                template.get("title", "") == "Initial setup"
                                and is_field_present_in_default_config(
                                    field, dbConfig, "configKey"
                                )
                                and "preRequisites" not in field
                            ):
                                schemaObject["required"].append(field["configKey"])

            for field in sdkTemplate.get("fields", []):
                generateFunction = uiTypetoSchemaFn.get(field["type"], None)
                if generateFunction:
                    properties[field["configKey"]] = generateFunction(
                        field, dbConfig, "configKey"
                    )
                if field.get(
                    "required", False
                ) == True and is_field_present_in_default_config(
                    field, dbConfig, "configKey"
                ):
                    schemaObject["required"].append(field["configKey"])

            for field in consentSettingsTemplate.get("fields", []):
                generateFunction = uiTypetoSchemaFn.get(field["type"], None)
                if generateFunction:
                    properties[field["configKey"]] = generateFunction(
                        field, dbConfig, "configKey"
                    )
                if field.get(
                    "required", False
                ) == True and is_field_present_in_default_config(
                    field, dbConfig, "configKey"
                ):
                    schemaObject["required"].append(field["configKey"])

            # default properties in new ui-config based schemas.
            schemaObject["properties"]["useNativeSDK"] = generate_schema_for_checkbox(
                {"type": "checkbox", "value": "useNativeSDK"}, dbConfig, "value"
            )
            schemaObject["properties"]["connectionMode"] = generate_connection_mode(
                dbConfig
            )
        else:
            # for sources
            def generate_config_props(config):
                for group in config:
                    fields = group.get("fields", [])
                    for field in fields:
                        generateFunction = uiTypetoSchemaFn.get(field["type"], None)
                        if generateFunction:
                            properties[field["value"]] = generateFunction(
                                field, dbConfig, "value"
                            )

            auth = uiConfig.get("auth", None)
            config = uiConfig.get("config", [])
            if auth:
                type = auth.get("type")
                if type == "form":
                    auth_config = auth.get("config", [])
                    generate_config_props(auth_config)

            generate_config_props(config)


def generate_schema(uiConfig, dbConfig, name, selector):
    """Returns the schema generated from given uiConfig and dbConfig.

    Args:
        uiConfig (object): file content of ui-config.json.
        dbConfig (object): Configurations of db-config.json.
        name (string): name of the source or destination.
        selector (string): either 'source' or 'destination'

    Returns:
        object: schema
    """
    newSchema = {}
    schemaObject = {}
    schemaObject["$schema"] = "http://json-schema.org/draft-07/schema#"
    schemaObject["required"] = []
    schemaObject["type"] = "object"
    schemaObject["properties"] = {}
    allOfSchemaObj = {}
    if is_old_format(uiConfig):
        allOfSchemaObj = generate_schema_for_allOf(uiConfig, dbConfig, "value")
    if allOfSchemaObj:
        # AnyOf occurring separately, not inside allOf.
        if len(allOfSchemaObj) == 1:
            if isinstance(allOfSchemaObj[0], list):
                schemaObject["anyOf"] = allOfSchemaObj[0]
            else:
                schemaObject["anyOf"] = allOfSchemaObj
        else:
            schemaObject["allOf"] = allOfSchemaObj
    generate_schema_properties(
        uiConfig, dbConfig, schemaObject, schemaObject["properties"], name, selector
    )
    newSchema["configSchema"] = schemaObject

    return newSchema


def generate_warnings_for_each_type(uiConfig, dbConfig, schema, curUiType):
    """Generates warning for each schema difference created by the current ui-type.

    Args:
        uiConfig (object): file content of ui-config.json.
        dbConfig (object): Configurations of db-config.json.
        schema (object): Existing schema in schema.json
        curUiType (string): Ui-Type for which warnings are generated.
    """
    if is_old_format(uiConfig):
        for uiConfigItem in uiConfig:
            for field in uiConfigItem["fields"]:
                if "preRequisiteField" in field:
                    continue
                if field["type"] == curUiType:
                    if field["value"] not in schema["properties"]:
                        warnings.warn(
                            f'{field["value"]} field is not in schema \n', UserWarning
                        )
                    else:
                        curSchemaField = schema["properties"][field["value"]]
                        newSchemaField = uiTypetoSchemaFn.get(curUiType)(
                            field, dbConfig, "value"
                        )
                        schemaDiff = get_json_diff(curSchemaField, newSchemaField)
                        if schemaDiff:
                            warnings.warn(
                                "For type:{} field:{} Difference is : \n\n {} \n".format(
                                    curUiType,
                                    field["value"],
                                    get_formatted_json(schemaDiff),
                                ),
                                UserWarning,
                            )
                    if (
                        curUiType == "textInput"
                        and field["value"] in schema["required"]
                        and "regex" not in field
                    ):
                        warnings.warn(
                            "For type:{} field:{} regex in ui-config and pattern in schema are mandatory for a required textInput \n".format(
                                curUiType,
                                field["value"],
                            ),
                            UserWarning,
                        )
    else:
        baseTemplate = uiConfig.get("baseTemplate", [])
        sdkTemplate = uiConfig.get("sdkTemplate", {})
        consentSettingsTemplate = uiConfig.get("consentSettingsTemplate", {})
        for template in baseTemplate:
            for section in template.get("sections", []):
                for group in section.get("groups", []):
                    if "preRequisites" in group:
                        continue
                    for field in group.get("fields", []):
                        if "preRequisites" in field:
                            continue
                        generateFunction = uiTypetoSchemaFn.get(field["type"], None)
                        if generateFunction and field["type"] == curUiType:
                            if field["configKey"] not in schema["properties"]:
                                warnings.warn(
                                    f'{field["configKey"]} field is not in schema \n',
                                    UserWarning,
                                )
                            else:
                                curSchemaField = schema["properties"][
                                    field["configKey"]
                                ]
                                newSchemaField = uiTypetoSchemaFn.get(curUiType)(
                                    field, dbConfig, "configKey"
                                )
                                schemaDiff = get_json_diff(
                                    curSchemaField, newSchemaField
                                )
                                if schemaDiff:
                                    warnings.warn(
                                        "For type:{} field:{} Difference is : \n\n {} \n".format(
                                            curUiType,
                                            field["configKey"],
                                            get_formatted_json(schemaDiff),
                                        ),
                                        UserWarning,
                                    )
                            if (
                                curUiType == "textInput"
                                and field["configKey"] in schema["required"]
                                and "regex" not in field
                            ):
                                warnings.warn(
                                    "For type:{} field:{} regex in ui-config and pattern in schema are mandatory for a required textInput \n".format(
                                        curUiType,
                                        field["configKey"],
                                    ),
                                    UserWarning,
                                )

        for field in sdkTemplate.get("fields", []):
            if "preRequisites" in field:
                continue
            generateFunction = uiTypetoSchemaFn.get(field["type"], None)
            if generateFunction:
                if generateFunction and field["type"] == curUiType:
                    if field["configKey"] not in schema["properties"]:
                        warnings.warn(
                            f'{field["configKey"]} field is not in schema \n',
                            UserWarning,
                        )
                    else:
                        curSchemaField = schema["properties"][field["configKey"]]
                        newSchemaField = uiTypetoSchemaFn.get(curUiType)(
                            field, dbConfig, "configKey"
                        )
                        schemaDiff = get_json_diff(curSchemaField, newSchemaField)
                        if schemaDiff:
                            warnings.warn(
                                "For type:{} field:{} Difference is : \n\n {} \n".format(
                                    curUiType,
                                    field["configKey"],
                                    get_formatted_json(schemaDiff),
                                ),
                                UserWarning,
                            )

        for field in sdkTemplate.get("fields", []):
            if "preRequisites" in field:
                continue
            generateFunction = uiTypetoSchemaFn.get(field["type"], None)
            if generateFunction:
                if generateFunction and field["type"] == curUiType:
                    if field["configKey"] not in schema["properties"]:
                        warnings.warn(
                            f'{field["configKey"]} field is not in schema \n',
                            UserWarning,
                        )
                    else:
                        curSchemaField = schema["properties"][field["configKey"]]
                        newSchemaField = uiTypetoSchemaFn.get(curUiType)(
                            field, dbConfig, "configKey"
                        )
                        schemaDiff = get_json_diff(newSchemaField, curSchemaField)
                        if schemaDiff:
                            warnings.warn(
                                "For type:{} field:{} Difference is : \n\n {} \n".format(
                                    curUiType, field["configKey"], schemaDiff
                                ),
                                UserWarning,
                            )

        for field in consentSettingsTemplate.get("fields", []):
            if "preRequisites" in field:
                continue
            generateFunction = uiTypetoSchemaFn.get(field["type"], None)
            if generateFunction:
                if generateFunction and field["type"] == curUiType:
                    if field["configKey"] not in schema["properties"]:
                        warnings.warn(
                            f'{field["configKey"]} field is not in schema \n',
                            UserWarning,
                        )
                    else:
                        curSchemaField = schema["properties"][field["configKey"]]
                        newSchemaField = uiTypetoSchemaFn.get(curUiType)(
                            field, dbConfig, "configKey"
                        )
                        schemaDiff = get_json_diff(newSchemaField, curSchemaField)
                        if schemaDiff:
                            warnings.warn(
                                "For type:{} field:{} Difference is : \n\n {} \n".format(
                                    curUiType, field["configKey"], schemaDiff
                                ),
                                UserWarning,
                            )


uiTypetoSchemaFn = {
    "defaultCheckbox": generate_schema_for_default_checkbox,
    "checkbox": generate_schema_for_checkbox,
    "textInput": generate_schema_for_textinput,
    "textareaInput": generate_schema_for_textarea_input,
    "singleSelect": generate_schema_for_single_select,
    "dynamicCustomForm": generate_schema_for_dynamic_custom_form,
    "dynamicForm": generate_schema_for_dynamic_form,
    "mapping": generate_schema_for_mapping,
    "dynamicSelectForm": generate_schema_for_dynamic_select_form,
    "tagInput": generate_schema_for_tag_input,
    "timeRangePicker": generate_schema_for_time_range_picker,
    "timePicker": generate_schema_for_time_picker,
}


def save_schema_to_file(selector, name, schema):
    # Get the parent directory (one level up)
    script_directory = os.path.dirname(os.path.abspath(__file__))
    directory = os.path.dirname(script_directory)

    # Define the relative path
    relative_path = f"{CONFIG_DIR}/{selector}s/{name}/schema.json"
    file_path = os.path.join(directory, relative_path)

    # Write the new content
    with open(file_path, "w") as file:
        file.write(get_formatted_json(schema))


def validate_config_consistency(
    name, selector, uiConfig, dbConfig, schema, shouldUpdateSchema
):
    """Generates a schema and compares it with an existing one.
    If schemaDiff is present, it calls for individual warnings by iterating over each ui-type.

    Args:
        name (string): name of the source or destination.
        selector (string): either 'source' or 'destination'
        uiConfig (object): file content of ui-config.json.
        dbConfig (object): Configurations of db-config.json.
        schema (object): Existing schema in schema.json.
        shouldUpdateSchema (boolean): if it should update the existing schema with generated one
    """
    if schema == None and uiConfig == None:
        return
    if uiConfig == None:
        print("-" * 50)
        warnings.warn(f"Ui-Config is null for {name} in {selector} \n", UserWarning)
        print("-" * 50)
        return
    generatedSchema = generate_schema(uiConfig, dbConfig, name, selector)

    if schema:
        schemaDiff = get_json_diff(schema, generatedSchema["configSchema"])
        if shouldUpdateSchema:
            finalSchema = {}
            finalSchema["configSchema"] = apply_json_diff(schema, schemaDiff)
            save_schema_to_file(selector, name, finalSchema)

        if schemaDiff:
            print("-" * 50)
            print(f"Schema diff for {name} in {selector}s")
            # call for individual warnings
            for uiType in uiTypetoSchemaFn.keys():
                generate_warnings_for_each_type(uiConfig, dbConfig, schema, uiType)
            # schema diff for "additionalProperties"
            if "additionalProperties" not in schema:
                print(
                    "\n Recommendation: Please set additionalProperties to False in schema.json. \n"
                )
            # schema diff for "required"
            if "required" not in schema:
                warnings.warn("required field is not in schema \n", UserWarning)
            else:
                curRequiredField = schema["required"]
                newRequiredField = generatedSchema["configSchema"]["required"]
                requiredFieldDiff = get_json_diff(curRequiredField, newRequiredField)
                if requiredFieldDiff:
                    warnings.warn(
                        "For required field Difference is :  \n\n {} \n".format(
                            get_formatted_json(requiredFieldDiff)
                        ),
                        UserWarning,
                    )
            if "allOf" in generatedSchema["configSchema"]:
                curAllOfSchema = {}
                if "allOf" in schema:
                    curAllOfSchema = schema["allOf"]
                newAllOfSchema = generatedSchema["configSchema"]["allOf"]
                allOfSchemaDiff = get_json_diff(curAllOfSchema, newAllOfSchema)
                if allOfSchemaDiff:
                    warnings.warn(
                        "For allOf field Difference is :  \n\n {} \n".format(
                            get_formatted_json(allOfSchemaDiff)
                        ),
                        UserWarning,
                    )
            if "anyOf" in generatedSchema["configSchema"]:
                curAnyOfSchema = {}
                if "anyOf" in schema:
                    curAnyOfSchema = schema["anyOf"]
                newAnyOfSchema = generatedSchema["configSchema"]["anyOf"]
                anyOfSchemaDiff = get_json_diff(curAnyOfSchema, newAnyOfSchema)
                if anyOfSchemaDiff:
                    warnings.warn(
                        "For anyOf field Difference is :  \n\n {} \n".format(
                            get_formatted_json(anyOfSchemaDiff)
                        ),
                        UserWarning,
                    )
            print("-" * 50)
    else:
        if shouldUpdateSchema:
            save_schema_to_file(selector, name, generatedSchema)

        print("-" * 50)
        print(f"Generated schema for {name} in {selector}s")
        print(get_formatted_json(generatedSchema))
        print("-" * 50)


def get_schema_diff(name, selector, shouldUpdateSchema=False):
    """Validates the schema for the given name and selector.

    Args:
        name (string): name of the source or destination.
        selector (string): either 'source' or 'destination'.
        shouldUpdateSchema (boolean): if it should update the existing schema with generated one
    """

    file_selectors = ["db-config.json", "ui-config.json", "schema.json"]
    directory = f"./{CONFIG_DIR}/{selector}s/{name}"
    if not os.path.isdir(directory):
        print(f"No {selector}s directory found for {name}")
        return

    if name not in EXCLUDED_DEST:
        available_files = os.listdir(directory)
        file_content = {}
        for file_selector in file_selectors:
            if file_selector in available_files:
                file_content.update(get_json_from_file(f"{directory}/{file_selector}"))
        uiConfig = file_content.get("uiConfig")
        schema = file_content.get("configSchema")
        dbConfig = file_content.get("config")

        validate_config_consistency(
            name, selector, uiConfig, dbConfig, schema, shouldUpdateSchema
        )


def update_test_file(supported_source_types, name):
    test_file_path = f"./test/data/validation/destinations/{name}.json"
    test_data = []
    if os.path.exists(test_file_path):
        test_data = get_json_from_file(test_file_path)

    # Clean up the test cases with existing consent management fields
    # This is needed only for the first run of the script on the base branch
    # for test in test_data:
    #     if "oneTrustCookieCategories" in test["config"]:
    #         del test["config"]["oneTrustCookieCategories"]
    #         if "err" in test:
    #             test["err"] = [err for err in test["err"] if "oneTrustCookieCategories" not in err]
    #     if "ketchConsentPurposes" in test["config"]:
    #         del test["config"]["ketchConsentPurposes"]
    #         if "err" in test:
    #             test["err"] = [err for err in test["err"] if "ketchConsentPurposes" not in err]

    #     if "err" in test and len(test["err"]) == 0:
    #         del test["err"]

    # Filter all the tests that have legacy consent management fields
    test_data = [
        test
        for test in test_data
        if "oneTrustCookieCategories" not in test["config"]
        and "ketchConsentPurposes" not in test["config"]
    ]

    # Filter invalid tests
    test_data = [
        test
        for test in test_data
        if ("result" in test and test["result"] is not False)
        or ("err" in test and len(test["err"]) > 0)
    ]

    success_test = {"config": {}}
    # Find a successful test case to clone
    for test in test_data:
        if test.get("result", False) and not test.get("err", None):
            success_test = test
            break

    # Positive test cases for oneTrustCookieCategories and ketchConsentPurposes
    # exploring different data formats and types
    one_trust_success_scenarios = [
        [{"oneTrustCookieCategory": "C0001"}, {"oneTrustCookieCategory": "C0002"}],
        [{"oneTrustCookieCategory": "C0003"}, {"oneTrustCookieCategory": "C0004"}],
        [{"oneTrustCookieCategory": ""}],
        [],
        [{"oneTrustCookieCategory": "env.ENVIRONMENT_VARIABLE"}],
        [
            {
                "oneTrustCookieCategory": "{"
                + "{"
                + " event.properties.prop1 || 'val' "
                + "}"
                + "}"
            }
        ],
    ]

    ketch_success_scenarios = [
        [{"purpose": "P1"}, {"purpose": "P2"}],
        [{"purpose": "P3"}, {"purpose": "P4"}],
        [{"purpose": ""}],
        [],
        [{"purpose": "env.ENVIRONMENT_VARIABLE"}],
        [{"purpose": "{" + "{" + " event.properties.prop1 || 'val' " + "}" + "}"}],
    ]

    # Prepare the test cases involving each source type
    s_idx = 0
    while s_idx < len(one_trust_success_scenarios):
        # Clone the successful test case and update the consent management fields
        success_test_clone = json.loads(json.dumps(success_test))

        success_test_clone["config"]["oneTrustCookieCategories"] = {}
        success_test_clone["config"]["ketchConsentPurposes"] = {}

        for source_type in supported_source_types:
            success_test_clone["config"]["oneTrustCookieCategories"][source_type] = (
                one_trust_success_scenarios[s_idx % len(one_trust_success_scenarios)]
            )
            success_test_clone["config"]["ketchConsentPurposes"][source_type] = (
                ketch_success_scenarios[s_idx % len(one_trust_success_scenarios)]
            )
            s_idx += 1

        success_test_clone["result"] = True
        test_data.append(success_test_clone)

    # Negative test case where oneTrustCookieCategories and ketchConsentPurposes are not objects
    # We don't want to repeat this scenario for each source type
    failure_test_1 = json.loads(json.dumps(success_test))
    failure_test_1["config"]["oneTrustCookieCategories"] = [
        {"oneTrustCookieCategory": "C0001"},
        {"oneTrustCookieCategory": "C0002"},
    ]
    failure_test_1["config"]["ketchConsentPurposes"] = [
        {"purpose": "P1"},
        {"purpose": "P2"},
    ]
    failure_test_1["result"] = False
    failure_test_1["err"] = [
        "oneTrustCookieCategories must be object",
        "ketchConsentPurposes must be object",
    ]

    test_data.append(failure_test_1)

    # Negative test cases for oneTrustCookieCategories and ketchConsentPurposes
    one_trust_failure_scenarios = [
        {
            "input": [
                {"someunsupportedkey": "C0001"},
                {
                    "oneTrustCookieCategory": "more than 100 characters string - AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
                },
                {"oneTrustCookieCategory": "C0004"},
            ],
            "error": [
                "oneTrustCookieCategories.ASDF.0 must NOT have additional properties",
                'oneTrustCookieCategories.ASDF.1.oneTrustCookieCategory must match pattern "(^\\{\\{.*\\|\\|(.*)\\}\\}$)|(^env[.].+)|^(.{0,100})$"',
            ],
        },
        {
            "input": [
                {"oneTrustCookieCategory": {"not": "a string"}},
                {"oneTrustCookieCategory": "C0004"},
            ],
            "error": [
                "oneTrustCookieCategories.ASDF.0.oneTrustCookieCategory must be string"
            ],
        },
        {
            "input": {"not": "an array"},
            "error": ["oneTrustCookieCategories.ASDF must be array"],
        },
        {
            "input": ["not an object", {"oneTrustCookieCategory": "C0004"}],
            "error": ["oneTrustCookieCategories.ASDF.0 must be object"],
        },
    ]

    ketch_failure_scenarios = [
        {
            "input": [
                {"someunsupportedkey": "P1"},
                {
                    "purpose": "more than 100 characters string - AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
                },
                {"purpose": "P4"},
            ],
            "error": [
                "ketchConsentPurposes.ASDF.0 must NOT have additional properties",
                'ketchConsentPurposes.ASDF.1.purpose must match pattern "(^\\{\\{.*\\|\\|(.*)\\}\\}$)|(^env[.].+)|^(.{0,100})$"',
            ],
        },
        {
            "input": [{"purpose": {"not": "a string"}}, {"purpose": "P4"}],
            "error": ["ketchConsentPurposes.ASDF.0.purpose must be string"],
        },
        {
            "input": {"not": "an array"},
            "error": ["ketchConsentPurposes.ASDF must be array"],
        },
        {
            "input": ["not an object", {"purpose": "P4"}],
            "error": ["ketchConsentPurposes.ASDF.0 must be object"],
        },
    ]

    s_idx = 0
    is_first = True
    failure_tcs = []
    while s_idx < len(one_trust_failure_scenarios):
        failure_test_clone = json.loads(json.dumps(success_test))
        failure_tcs.append(failure_test_clone)

        failure_test_clone["err"] = []
        failure_test_clone["config"]["oneTrustCookieCategories"] = {}
        if is_first:
            failure_test_clone["config"]["oneTrustCookieCategories"][
                "someunsupportedsourcetype"
            ] = [
                {"oneTrustCookieCategory": "C0001"},
                {"oneTrustCookieCategory": "C0002"},
            ]
            failure_test_clone["err"].append(
                "oneTrustCookieCategories must NOT have additional properties"
            )
            is_first = False

        for source_type in supported_source_types:
            if s_idx >= len(one_trust_failure_scenarios):
                break
            failure_test_clone["config"]["oneTrustCookieCategories"][source_type] = (
                one_trust_failure_scenarios[s_idx]["input"]
            )
            failure_test_clone["err"].extend(
                [
                    x.replace("ASDF", source_type)
                    for x in one_trust_failure_scenarios[s_idx]["error"]
                ]
            )

            s_idx += 1

        failure_test_clone["result"] = False

    s_idx = 0
    is_first = True
    tc_idx = 0
    while s_idx < len(ketch_failure_scenarios):
        failure_test_clone = failure_tcs[tc_idx]
        tc_idx += 1

        failure_test_clone["config"]["ketchConsentPurposes"] = {}
        if is_first:
            failure_test_clone["config"]["ketchConsentPurposes"][
                "someunsupportedsourcetype"
            ] = [{"purpose": "P1"}, {"purpose": "P2"}]
            failure_test_clone["err"].append(
                "ketchConsentPurposes must NOT have additional properties"
            )
            is_first = False

        for source_type in supported_source_types:
            if s_idx >= len(ketch_failure_scenarios):
                break
            failure_test_clone["config"]["ketchConsentPurposes"][source_type] = (
                ketch_failure_scenarios[s_idx]["input"]
            )
            failure_test_clone["err"].extend(
                [
                    x.replace("ASDF", source_type)
                    for x in ketch_failure_scenarios[s_idx]["error"]
                ]
            )

            s_idx += 1

        failure_test_clone["result"] = False

        test_data.append(failure_test_clone)

    # write to file
    with open(test_file_path, "w") as f:
        f.write(get_formatted_json(test_data))


def update_schema_file(supported_source_types, name, dir_path):
    schema_file = f"./{dir_path}/{name}/schema.json"
    schema = {}

    if os.path.exists(schema_file):
        schema = get_json_from_file(schema_file)

    config_schema = None
    if "configSchema" in schema:
        config_schema = schema["configSchema"]

    if not config_schema:
        config_schema = {
            "$schema": "http://json-schema.org/draft-07/schema#",
            "type": "object",
            "properties": {},
        }

    one_trust_cookie_categories_schema = {}
    one_trust_cookie_categories_schema["type"] = "object"
    one_trust_cookie_categories_schema["properties"] = {}
    for source_type in supported_source_types:
        one_trust_cookie_categories_schema["properties"][source_type] = {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "oneTrustCookieCategory": {
                        "type": "string",
                        "pattern": "(^\\{\\{.*\\|\\|(.*)\\}\\}$)|(^env[.].+)|^(.{0,100})$",
                    }
                },
                "additionalProperties": False,
            },
        }
    one_trust_cookie_categories_schema["additionalProperties"] = False
    config_schema["properties"][
        "oneTrustCookieCategories"
    ] = one_trust_cookie_categories_schema

    ketch_consent_schema = {}
    ketch_consent_schema["type"] = "object"
    ketch_consent_schema["properties"] = {}
    for source_type in supported_source_types:
        ketch_consent_schema["properties"][source_type] = {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "purpose": {
                        "type": "string",
                        "pattern": "(^\\{\\{.*\\|\\|(.*)\\}\\}$)|(^env[.].+)|^(.{0,100})$",
                    }
                },
                "additionalProperties": False,
            },
        }
    ketch_consent_schema["additionalProperties"] = False
    config_schema["properties"]["ketchConsentPurposes"] = ketch_consent_schema

    schema["configSchema"] = config_schema

    with open(schema_file, "w") as f:
        f.write(get_formatted_json(schema))


def update_ui_config_file(name, dir_path):
    ui_config_file = f"./{dir_path}/{name}/ui-config.json"
    ui_config = get_json_from_file(ui_config_file)

    if is_old_format(ui_config["uiConfig"]):
        # Search for existing consent settings section
        consent_settings = None
        for section in ui_config["uiConfig"]:
            if "title" in section and section["title"] == "Consent Settings":
                consent_settings = section
                break

        gcm_config = None
        conf_index = -1
        if consent_settings:
            # Search for existing GCM settings
            conf_index = ui_config["uiConfig"].index(consent_settings)
            for group in consent_settings["fields"]:
                if "label" in group and group["label"] == "Consent management settings":
                    gcm_config = group
                    break

            # and remove the existing consent settings section
            ui_config["uiConfig"].remove(consent_settings)

        # Standard consent settings section with legacy fields
        consent_settings = {
            "title": "Consent Settings",
            "fields": [
                {
                    "type": "dynamicCustomForm",
                    "value": "oneTrustCookieCategories",
                    "label": "OneTrust Consent Category IDs",
                    "footerNote": "The support for category names is deprecated. We recommend using the category IDs instead of the names as IDs are unique and less likely to change over time, making them a more reliable choice.",
                    "customFields": [
                        {
                            "type": "textInput",
                            "placeholder": "C0001",
                            "value": "oneTrustCookieCategory",
                            "regex": "(^\\{\\{.*\\|\\|(.*)\\}\\}$)|(^env[.].+)|^(.{0,100})$",
                            "label": "Category ID",
                            "required": False,
                        }
                    ],
                    "preRequisites": {
                        "featureFlags": [
                            {"configKey": "AMP_enable-gcm", "value": False},
                            {"configKey": "AMP_enable-gcm"},
                        ],
                        "featureFlagsCondition": "or",
                    },
                },
                {
                    "type": "dynamicCustomForm",
                    "value": "ketchConsentPurposes",
                    "label": "Ketch Consent Purpose IDs",
                    "customFields": [
                        {
                            "type": "textInput",
                            "placeholder": "marketing",
                            "value": "purpose",
                            "label": "Purpose ID",
                            "regex": "(^\\{\\{.*\\|\\|(.*)\\}\\}$)|(^env[.].+)|^(.{0,100})$",
                            "required": False,
                        }
                    ],
                    "preRequisites": {
                        "featureFlags": [
                            {"configKey": "AMP_enable-gcm", "value": False},
                            {"configKey": "AMP_enable-gcm"},
                        ],
                        "featureFlagsCondition": "or",
                    },
                },
            ],
        }

        # Restore the GCM settings if it was present
        if gcm_config:
            consent_settings["fields"].append(gcm_config)

        # Restore the new consent settings in the same position
        # or append it to the end of the uiConfig
        if conf_index != -1:
            ui_config["uiConfig"].insert(conf_index, consent_settings)
        else:
            ui_config["uiConfig"].append(consent_settings)

    else:
        configuration_settings = None
        one_trust_consent_settings_found = False
        ketch_consent_settings_found = False
        one_trust_consent_settings = False
        ketch_consent_settings = False
        other_settings = None
        consent_settings = None
        consent_settings_template = None
        base_template = ui_config["uiConfig"]["baseTemplate"]

        for key in ui_config["uiConfig"]:
            if key == "baseTemplate":
                for template_entry in base_template:
                    # Search for existing consent settings sections
                    if (
                        "title" in template_entry
                        and template_entry["title"] == "Configuration settings"
                    ):
                        configuration_settings = template_entry
                        for section in template_entry["sections"]:
                            if (
                                not other_settings
                                and "title" in section
                                and section["title"] == "Other settings"
                            ):
                                other_settings = section
                                for group in section["groups"]:
                                    if "title" in group and (
                                        group["title"] == "OneTrust consent settings"
                                        or group["title"]
                                        == "OneTrust cookie consent settings"
                                    ):
                                        one_trust_consent_settings_found = True
                                        one_trust_consent_settings = group
                                    elif (
                                        "title" in group
                                        and group["title"] == "Ketch consent settings"
                                    ):
                                        ketch_consent_settings_found = True
                                        ketch_consent_settings = group

                            if (
                                not consent_settings
                                and "title" in section
                                and section["title"] == "Consent settings"
                            ):
                                consent_settings = section

                        # Remove the existing consent settings sections
                        if (
                            one_trust_consent_settings_found
                            and one_trust_consent_settings
                        ):
                            other_settings["groups"].remove(one_trust_consent_settings)

                        # Remove the existing consent settings sections
                        if ketch_consent_settings_found and ketch_consent_settings:
                            other_settings["groups"].remove(ketch_consent_settings)
            elif not consent_settings_template and key == "consentSettingsTemplate":
                consent_settings_template = ui_config["uiConfig"][key]

                for field in consent_settings_template["fields"]:
                    if (
                        "label" in field
                        and field["label"] == "OneTrust consent category IDs"
                    ):
                        one_trust_consent_settings = field
                        one_trust_consent_settings_found = True
                    elif (
                        "label" in field
                        and field["label"] == "Ketch consent purpose IDs"
                    ):
                        ketch_consent_settings = field
                        ketch_consent_settings_found = True

                # delete onetrust and ketch consent settings from the template
                if one_trust_consent_settings_found and one_trust_consent_settings:
                    consent_settings_template["fields"].remove(
                        one_trust_consent_settings
                    )
                if ketch_consent_settings_found and ketch_consent_settings:
                    consent_settings_template["fields"].remove(ketch_consent_settings)

        # Standard consent settings section with legacy fields
        new_consent_settings_section = {
            "id": "consentSettings",
            "title": "Consent settings",
            "note": "Configure consent settings for each provider here",
            "icon": "settings",
            "groups": [],
        }

        if not configuration_settings:
            configuration_settings = {
                "title": "Configuration settings",
                "note": "Manage the settings for your destination",
                "sections": [new_consent_settings_section],
            }
            base_template.append(configuration_settings)
        else:
            if consent_settings:
                configuration_settings["sections"].remove(consent_settings)

            if other_settings:
                # Insert the new consent settings section before the other settings section
                other_settings_idx = configuration_settings["sections"].index(
                    other_settings
                )
                configuration_settings["sections"].insert(
                    other_settings_idx, new_consent_settings_section
                )

                # Remove the other settings section if it's empty
                if len(other_settings["groups"]) == 0:
                    configuration_settings["sections"].remove(other_settings)
            else:
                configuration_settings["sections"].append(new_consent_settings_section)

        legacy_fields = [
            {
                "type": "tagInput",
                "label": "OneTrust consent category IDs",
                "note": "Input your OneTrust category IDs by pressing 'Enter' after each entry.",
                "configKey": "oneTrustCookieCategories",
                "tagKey": "oneTrustCookieCategory",
                "placeholder": "e.g: C0001",
                "default": [{"oneTrustCookieCategory": ""}],
                "preRequisites": {
                    "featureFlags": [
                        {"configKey": "AMP_enable-gcm", "value": False},
                        {"configKey": "AMP_enable-gcm"},
                    ],
                    "featureFlagsCondition": "or",
                },
            },
            {
                "type": "tagInput",
                "label": "Ketch consent purpose IDs",
                "note": "Input your Ketch consent purpose IDs by pressing 'Enter' after each entry.",
                "configKey": "ketchConsentPurposes",
                "tagKey": "purpose",
                "placeholder": "e.g: marketing",
                "default": [{"purpose": ""}],
                "preRequisites": {
                    "featureFlags": [
                        {"configKey": "AMP_enable-gcm", "value": False},
                        {"configKey": "AMP_enable-gcm"},
                    ],
                    "featureFlagsCondition": "or",
                },
            },
        ]

        if not consent_settings_template:
            consent_settings_template = {
                "title": "Consent settings",
                "note": "not visible in the ui",
                "fields": legacy_fields,
            }
            ui_config["uiConfig"]["consentSettingsTemplate"] = consent_settings_template
        else:
            legacy_fields.reverse()
            for field in legacy_fields:
                consent_settings_template["fields"].insert(0, field)

    with open(ui_config_file, "w") as f:
        f.write(get_formatted_json(ui_config))


def update_db_config_file(name, dir_path):
    db_config_file = f"./{dir_path}/{name}/db-config.json"

    db_config = get_json_from_file(db_config_file)
    supported_source_types = db_config["config"]["supportedSourceTypes"]

    default_config = db_config["config"]["destConfig"]["defaultConfig"]
    if "ketchConsentPurposes" in default_config:
        default_config.remove("ketchConsentPurposes")

    if "oneTrustCookieCategories" in default_config:
        default_config.remove("oneTrustCookieCategories")

    db_config["config"]["destConfig"]["defaultConfig"] = default_config

    device_mode_supported = False
    if "supportedConnectionModes" in db_config["config"]:
        for source_type in db_config["config"]["supportedConnectionModes"]:
            if (
                "device" in db_config["config"]["supportedConnectionModes"][source_type]
                or "hybrid"
                in db_config["config"]["supportedConnectionModes"][source_type]
            ):
                device_mode_supported = True
                break

    for source_type in db_config["config"]["destConfig"]:
        source_type_config = db_config["config"]["destConfig"][source_type]
        if (
            "useNativeSDK" in source_type_config
            or "useNativeSDKToSend" in source_type_config
        ):
            device_mode_supported = True
            break

    if device_mode_supported:
        include_keys = []
        if "includeKeys" in db_config["config"]:
            include_keys = db_config["config"]["includeKeys"]
        if "oneTrustCookieCategories" not in include_keys:
            include_keys.append("oneTrustCookieCategories")
        if "ketchConsentPurposes" not in include_keys:
            include_keys.append("ketchConsentPurposes")

        db_config["config"]["includeKeys"] = include_keys

    for source_type in supported_source_types:
        source_type_config = []
        if source_type in db_config["config"]["destConfig"]:
            source_type_config = db_config["config"]["destConfig"][source_type]
        else:
            print(f"Warning: {source_type} not found in destConfig for {name}")

        if "oneTrustCookieCategories" not in source_type_config:
            source_type_config.append("oneTrustCookieCategories")

        if "ketchConsentPurposes" not in source_type_config:
            source_type_config.append("ketchConsentPurposes")

        db_config["config"]["destConfig"][source_type] = source_type_config

    # update the file with new config
    with open(db_config_file, "w") as f:
        f.write(get_formatted_json(db_config))


def get_supported_source_types(name, dir_path):
    db_config_file = f"./{dir_path}/{name}/db-config.json"
    supported_source_types = []
    db_config = get_json_from_file(db_config_file)
    supported_source_types = db_config["config"]["supportedSourceTypes"]
    return supported_source_types


def restructure_legacy_consent_fields(dest_names, dir_path):
    for name in dest_names:
        # check if name is a directory
        if not os.path.isdir(f"./{dir_path}/{name}"):
            continue

        update_db_config_file(name, dir_path)
        supported_source_types = get_supported_source_types(name, dir_path)
        update_schema_file(supported_source_types, name, dir_path)
        update_test_file(supported_source_types, name)
        update_ui_config_file(name, dir_path)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Generates schema.json from ui-config.json and db-config.json and validates against actual scheme.json"
    )
    group = parser.add_mutually_exclusive_group()
    parser.add_argument(
        "selector",
        metavar="selector",
        type=str,
        help="Enter whether -name is a source or destination",
    )
    parser.add_argument(
        "-update",
        action="store_true",
        help="Will update existing schema with any changes",
    )
    parser.add_argument("-restructureLegacyConsentFields", action="store_true")
    group.add_argument(
        "-name", metavar="name", type=str, help="Enter the folder name under selector"
    )
    group.add_argument(
        "-all",
        action="store_true",
        help="Will run validation for all entities under selector",
    )

    args = parser.parse_args()
    selector = args.selector
    shouldUpdateSchema = args.update
    restructureLegacyConsentFields = args.restructureLegacyConsentFields

    dir_path = f"./{CONFIG_DIR}/{selector}s"
    if args.all:
        if not os.path.isdir(dir_path):
            print(f"No {selector}s folder found")
            exit(1)

        if restructureLegacyConsentFields:
            restructure_legacy_consent_fields(os.listdir(dir_path), dir_path)
        else:
            current_items = os.listdir(dir_path)
            for name in current_items:
                get_schema_diff(name, selector, shouldUpdateSchema)
    else:
        name = args.name
        if restructureLegacyConsentFields:
            restructure_legacy_consent_fields(
                [dest_name.strip() for dest_name in name.split(",")], dir_path
            )
        else:
            get_schema_diff(name, selector, shouldUpdateSchema)
